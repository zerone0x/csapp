# bit
64/32bit means its address is 64bit --> 8 bytes
# boolean
xor(not both
![](https://i.imgur.com/LwBlLHZ.png)
# diff between arith/logical shift
![](https://i.imgur.com/v7couz5.png)
For arith, it completes with the first number <-- sign num
# sign unsign
signed --> include the negative symbol
unsigned --> not include
![](https://i.imgur.com/I5hdDvB.png)
 TMax = TMin -1
``` 
UMax=2TMax+1 
```
![](https://i.imgur.com/bl4nRks.png)
sizeof()-->unsigned
# sign extension
![](https://i.imgur.com/KrO5ht5.png)
![](https://i.imgur.com/O2F1zao.png)
# Truncate

![](https://i.imgur.com/lAqKakE.png)
From negative to positive
![](https://i.imgur.com/E8nE1tZ.png)

---

# integers
addition works ok on unsigned
	not ok on signed(negative/positive overflow)
	It its too high --> become negative > 2^w-1
	otherwise --> positive < 2^w-1
The shold between right value and signed shold is the 2^w
# change x to -x
x --> ~ --> +1 --> -x
# unsigned(used in mod calculate)
![](https://i.imgur.com/NmkxdSO.png)
# Representations in memory, pointers, strings
![](https://i.imgur.com/gfGwpM4.png)



